摄像机剔除
Window->Rendering->Occlusion Culling

摄像机剔除其实就是在渲染正常的情况下避免overdraw,因为在unity运行过程中我们需要对render进行渲染后通过queue,或ztest才可以知道真正的渲染结果,而这个过程中我们会涉及到过多的GPU处理,另外在计算过程中我们还需要计算各种光照处理,对游戏的性能损耗会特别严重,那么对于很多背景来说我们其实就可以通过烘焙的形式去处理。将一些渲染的计算包括各种光照形成贴图重新赋给mesh,这种情况下我们还可以通过遮挡来避免渲染后面的物体,比如当前位置如下：
摄像机 > 物体A > 物体B

首先我们需要先将物体A/B设置为 Static Occluder[静态遮挡物] / Static Occludee[被遮挡物],然后我们去Occlusion窗口点击bake

简单的设置就做好了。
下面的结果验证
摄像机 > 物体A > 物体B  此时只会渲染 物体A[完全遮挡住B]
随着摄像机的移动
物体A > 摄像机 > 物体B  此时A隐藏,B渲染

！！！！注意:
1)经过测试如果摄像机没有被物体A完全挡住的情况下,B还是需要渲染的
2)另外有个还需要区别的是,其实摄像机本身也会有剔除,那个也只是不在摄像机FOV的情况下做得.但是在A挡住B的时候B还是需要渲染的
3)因为都设置为static了.烘焙后已经不能移动被烘焙的物体了

设置“门” --- 因为有的时候比如说有个洞,洞里有个门,我们想在门关闭的时候剔除后面的物体,当门打开的时候,后面可以看到的物体开始渲染,
怎么做呢？好奇怪,这个时候我们我们可以使用一个组件 Occlusion Portal
例如我们用A做门,使用方法为将B设置为遮挡/被遮挡物同时保证A不被设置.然后点击烘焙.这样就行了.当Portal组件中oPen开启的时候后面的B被渲染
如果open=false的时候,B不被渲染[切记加了portal之后才点击bake]

关于动态游戏对象的遮挡剔除
这个只能充当被遮挡物,不能充当遮挡物,在mesh上有一个参数是 Dynamic Occlusion 
启用 Dynamic Occlusion 后，渲染器在摄像机的视图中被静态遮挡物 (Static Occluder) 阻挡时，Unity 会剔除渲染器。禁用 Dynamic Occlusion 后，渲染器在摄像机的视图中被静态遮挡物 (Static Occluder) 阻挡时，Unity 不会剔除渲染器



