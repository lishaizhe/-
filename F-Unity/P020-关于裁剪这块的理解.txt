比如说我们在Unity视野外存在一些建筑,那么这些建筑是否会显示呢,又是否会经过顶点运算呢？？？

其实不会,在Unity中我们的渲染流程为


1.视椎体剔除  [[[[[  这个是逻辑阶段的,比如说A.prefab有一部分在视野内,你们整个也是不会被剔除掉的,和线面的clip不同  ]]]]]
			这个是在CPU阶段处理的,Unity内部提供的算法机制,使得完全不在视野内的东西,经过底层基于四叉树的算法进行剔除,那么这样就无需再经过GPU了
			从而减轻渲染的压力。因为基于Unity的这种算法机制,其实节点数的多少没有太大的压力,所以我们也没有太大的必要非要做手动culling

			但是Unity中默认shadowmap的生成会大幅影响视椎体剔除的范围,对于移动平台来讲如果不使用实时阴影的情况下,可以尝试关闭灯的阴影投射或者
			去掉简单shader中的fallback(通常会含有shadowcaster),就会使同屏渲染面数大幅减小


2.遮挡剔除   	[[[[[  这个是针对于场景中的static的,定义成static后,需要多出来一份内存数据,里面存放uv,normal等一些列的数据  ]]]]]
			发生在应用程序阶段(Application Stage)，由游戏引擎实现，运行在CPU上。
			以Unity为例，需要根据场景中Static物体的位置预先生成场景OcclusionCulling数据，运行时就可以剔除对应静态物体之后的其他物体。
			遮挡剔除是减少渲染消耗的有效手段之一，可以和视椎体剔除同时生效，进一步减少渲染的消耗。

			针对Unity中遮挡剔除中的使用和研究，https://blog.csdn.net/cartzhang/article/details/52684127 中总结的很好。

			随着硬件技术的提升，目前GPU已经可以支持在没有应用程序阶段额外数据的支持下在硬件侧面实现遮挡剔除
			(在光栅化之后，像素着色器之前，优于渲染管线末尾才进行的深度剔除) 
			https://blog.csdn.net/cartzhang/article/details/72420731 一文中提到

			现代GPU中运用了Early-Z的技术，在Vertex阶段和Fragment阶段之间（光栅化之后，fragment之前）进行一次深度测试，
			如果深度测试失败，就不必进行fragment阶段的计算了，因此在性能上会有很大的提升。但是最终的ZTest仍然需要进行，
			以保证最终的遮挡关系结果正确。



3.裁剪Clipping
			[[[[[[   clip是发生在GPU阶段,在上面视椎体剔除后,A.prefab还存在,但是在这个地方就会把不在视野内的顶点给剔除掉   ]]]]]]
			发生在几何阶段(Geometry Stage)后期，投影变换之后屏幕映射之前，是渲染管线的必要一环。
			只有当图元完全或部分存在于规范立方体内部（摄像机视野内）的时候，才将其返送到光栅化阶段。
			其中，对于完全位于规范立方体内部的图元，则直接进行下一阶段；完全处于规范立方外部的图元则完全被舍弃；
			部分处于规范立方体内部图元，则会根据摄像机视野进行对应的裁剪，在这一过程中可能会产生新的顶点。

			通过裁剪Clipping可以将摄像机视野外的图元舍弃掉，减小光栅化阶段的消耗。



4.背面剔除
			背面剔除即是将背向视点的图元剔除，因为它们对最终渲染的图像没有贡献。这是一种简单直观的操作，一次对一个多边形进行操作。
			剔除的基本原理是先判定多边形的朝向，并和当前的观察方向进行比较

			更为详细的说明可以在《Real-Time Rendering》第14章加速算法找到，也可参照浅墨大大的总结文章 
			https://blog.csdn.net/poem_qianmo/article/details/78884513

			Unity中的背面剔除在光栅化阶段进行，执行在Vertex Shader 之后，在Fragment Shader片元着色器之前，
			通过Shader中的Cull指令来控制背面剔除的开启和关闭， 
			Unity手册上的图示显示的比较清晰： https://docs.unity3d.com/Manual/SL-CullAndDepth.html


5.深度剔除
			在Fragment Shader之后，光栅化阶段末期的融合阶段执行，又叫深度检测(或Z缓存检测)。
			每次将一个图元回执为相应的像素时，都会计算像素位置处图元的深度值，和深度缓存中对应像素的值进行比较，
			如果新计算出的深度小于缓存中的深度，则更新深度缓存中的值；如果深度值大于深度缓冲中的值，则计算结果被舍弃，深度缓冲的值也无需更新。

			在执行深度剔除时，已经位于渲染管线末尾，所有的颜色计算都已经完成，因此意义只在处理图元的可见性问题，
			对于渲染的消耗基本没有影响，不是优化时需要重点考察的问题。











