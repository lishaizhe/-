RectTransformUtility

=======================================================    
public static Vector2 PixelAdjustPoint(Vector2 point, Transform ele, Canvas cavas)
//将屏幕空间中的point转成像素校正点


=======================================================
void FlipLayoutAxes(RectTransform rect, bool keepPositioning, bool recursive)
顺时针旋转
keepPositioning true 表示围绕自身的pivot旋转  false的时候表示绕着父物体旋转
recursive 表示是否带着子物体旋转  true带着子物体  false只是自身旋转

=======================================================
void FlipLayoutOnAxis(RectTransform rect, int axis, bool keepPosition, bool recursive)
把rectTransform做水平或者垂直的翻转  axis ==0 水平   ==1 竖直


=======================================================
bool ScreenPointToLocalPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector2 localPoint); 

把一个屏幕空间上的点，转换成rect的内部坐标，Canvas 的RenderMode在Camera和World模式下，
传入的camera为UI摄像机，在OverLay，camara参数应该传入null


=======================================================
bool ScreenPointToWorldPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector3 worldPoint)，把屏幕坐标转换成在rect这个实参平面内的世界坐标，这个函数可能会比较难搞懂一些，可以理解为在屏幕坐标ScrrenPoint处发条Z方向的射线，
摄像与rect的交点就是返回的世界坐标worldPoint


**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************

localToWorldMatrix  transform  是一个Matrix4x4矩阵



https://zhuanlan.zhihu.com/p/552267130
Texture.totalTextureMemory：即加载全部level=0的texture需要的内存
Texture.desiredTextureMemory：实际加载的texture所占内存，当未开启TextureStreaming时，该值等于Texture.totalTextureMemory
Textrure2D.calculateMipLevel：某个texture，在当前相机距离下需要加载的等级
Textrure2D.desiredMipLevel：某个texture，在当前相机距离下实际加载的等级
Textrure2D.requestedMipmapLevel：某个texture，加载指定的等级


LayoutRebuilder.MarkLayoutForRebuild(rectTransform);

CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);


Texture2D.ReadPixels(rect, dx, dy)  这个是将当前屏幕的纹理,读取到texture2d中
rect表示采样的范围
dx, dy表示在当前范围上的偏移



sprite中有一个overrideSprite
这个着实是一个诡异的东西,他和.sprite不同
.sprite是真正的替换,这个overrideSprite是一个覆盖在上面的图片,如果设置了值看到的就是这个图片
当然如果我们已经设置了overrideSprite，此时再设置sprite也是看不到的，还需要设置override那个
如果想把override干掉，直接设置为null

Sprites.DataUtility.GetPadding 返回vector4  
如果图片被打成图集的话,其周边的透明区域会被裁剪掉,这个就是返回被裁剪掉的大小
vector4对应的依次为  x left  y bottom  z right  w top






**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************
**********************************************************************************************************************************


要更改显示在其他元素之上的元素，只需通过拖动元素在层次结构中重新排序它们即可。通过在 Transform 组件上使用以下方法，也可以从脚本控制顺序：SetAsFirstSibling、SetAsLastSibling 和 SetSiblingIndex。



[FormerlySerializedAs("m_MyVariable")]  -- 这个函数比较有意思
如果你之前定义为public GameObject m_A;
如果此时你想修改变量名字为 m_B,那么你拖动的那些链接就会丢失,那么怎么办呢
我们使用 
[FormerlySerializedAs("m_A")]
public GameObject m_B 
这样就没有问题了.或者是那个 [Serialized] private GameObject m_A;


============================================== 宏定义 ==============================================
[System.Diagnostics.Conditional("LOG")]  -- 宏定义的处理





